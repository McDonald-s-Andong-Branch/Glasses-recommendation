<!DOCTYPE html>
<html>
<head>
  <title>스노우 웹 페이지</title>
</head>
<body>
  <video id="videoElement" width="640" height="480" autoplay></video>
  <canvas id="canvasElement" width="640" height="480"></canvas>

  <script>
    // 비디오 및 캔버스 요소 가져오기
    const videoElement = document.getElementById('videoElement');
    const canvasElement = document.getElementById('canvasElement');
    const context = canvasElement.getContext('2d');

    // 미디어 스트림 요청
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(function(stream) {
        videoElement.srcObject = stream;
      })
      .catch(function(error) {
        console.error("미디어 스트림을 가져오는데 실패했습니다: ", error);
      });

    // 스티커 씌우기 함수
    function applySticker(result) {
      // 스티커 이미지 로드
      const stickerImage = new Image();
      stickerImage.src = 'path/to/sticker.png'; // 적용할 스티커 이미지 경로를 입력해주세요

      stickerImage.onload = function() {
        // 캔버스에 얼굴 검출 결과 그리기
        context.drawImage(videoElement, 0, 0, canvasElement.width, canvasElement.height);
        
        // 얼굴 검출 결과를 기반으로 스티커 씌우기
        const faces = result.faces;
        for (let i = 0; i < faces.length; i++) {
          const face = faces[i];
          const x = face.x; // 얼굴 위치 x 좌표
          const y = face.y; // 얼굴 위치 y 좌표
          const width = face.width; // 얼굴 너비
          const height = face.height; // 얼굴 높이

          // 스티커 위치 및 크기 설정
          const stickerScale = 1.5; // 스티커 크기 비율
          const stickerWidth = width * stickerScale; // 스티커 너비
          const stickerHeight = stickerWidth * (stickerImage.height / stickerImage.width); // 스티커 높이
          const stickerX = x + width / 2 - stickerWidth / 2; // 스티커 x 좌표
          const stickerY = y + height / 2 - stickerHeight / 2; // 스티커 y 좌표
          
          // 스티커 이미지를 캔버스에 그리기
          context.drawImage(stickerImage, stickerX, stickerY, stickerWidth, stickerHeight);
        }
      };
    }

    // 얼굴 검출 API 호출 및 스티커 씌우기 함수 호출
    function detectFaces() {
      // TensorFlow.js 모델 로드
      Promise.all([
        faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages.mediapipeFacemesh),
        faceApi.nets.tinyFaceDetector.loadFromUri('path/to/models'),
        faceApi.nets.faceRecognitionNet.loadFromUri('path/to/models'),
        faceApi.nets.faceLandmark68Net.loadFromUri('path/to/models'),
        faceApi.nets.ssdMobilenetv1.loadFromUri('path/to/models')
      ])
      .then(function([mediapipeModel, tinyFaceDetectorModel, faceRecognitionNetModel, faceLandmark68NetModel, ssdMobilenetv1Model]) {
        console.log('모델 로딩이 완료되었습니다.');

        // 얼굴 검출 모델 초기화
        const faceDetectionOptions = new faceApi.TinyFaceDetectorOptions({ inputSize: 512, scoreThreshold: 0.5 });
        const faceDetectionTask = new faceApi.FaceDetectionTask(tinyFaceDetectorModel, faceDetectionOptions);

        // 비디오 프레임마다 얼굴 검출 수행
        setInterval(async function() {
          const videoWidth = videoElement.videoWidth;
          const videoHeight = videoElement.videoHeight;

          canvasElement.width = videoWidth;
          canvasElement.height = videoHeight;

          const faces = await faceDetectionTask.detect(videoElement);

          // 얼굴 검출 결과를 기반으로 스티커 씌우기 함수 호출
          applySticker({ faces: faces.map(face => ({ x: face.box.x, y: face.box.y, width: face.box.width, height: face.box.height })) });
        }, 100);
      })
      .catch(function(error) {
        console.error("모델 로딩에 실패했습니다: ", error);
      });
    }

    // 페이지 로드 시 얼굴 검출 함수 호출
    window.addEventListener('load', detectFaces);
  </script>
</body>
</html>
